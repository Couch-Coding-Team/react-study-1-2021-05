## UseReducer

- Old state, action => Recucer => New state
- useReduce 상태관리 : 상태를 업데이트 하는 방법중 하나로 useState와 다른방법
- 컴포넌트 상태 업데이트 로직을 컴포넌트에서 분리가능
- 업데이트 로직을 컴포넌트 바깥에 작성 가능
- 다른파일에 작성한 후 불러와서 사용가능
- 리액트는 state를 변경하면 바뀐부분을 새로 그리기 위해 해당하는 모든컴포넌트를 다시 실행한다
- 간단한 프로젝트일때는 충분히 잘 동작하지만 스케일이 커지는 프로젝트일수록 코드를 체계적으로 관리하고 최적화에 도움을 줄 수 있다
- 코드량이 늘어나지만 일관적인 구조를 가지고 있기 때문에 로직을 파악하기 쉽고 체계적이다
- 컴포넌트에서 관리하는 값이 적다면 useState로 관리하는 값이 여러개가 되어서 상태의 구조가 복잡해 진다면 useReducer로 관리하는게 좋을수도



### Counter.js

```react
//import React, { useState } from 'react';
import React, { useReducer } from 'react';

function reducer(state, action) {
    switch (action.type) {
      case 'INCREMENT':
        return state + 1;
      case 'DECREMENT':
        return state - 1;
      default:
        return state;
    }
  }

function Counter() {
  //const [number, setNumber] = useState(0);
  const [number, dispatch] = useReducer(reducer, 0);

  const onIncrease = () => {
    //setNumber(prevNumber => prevNumber + 1);
    dispatch({ type: 'INCREMENT' });
  };

  const onDecrease = () => {
    //setNumber(prevNumber => prevNumber - 1);
    dispatch({ type: 'DECREMENT' });
  };

  return (
    <div>
      <h1>{number}</h1>
      <button onClick={onIncrease}>+1</button>
      <button onClick={onDecrease}>-1</button>
    </div>
  );
}

export default Counter;
```



### App.js

```react
import React, { useRef, useReducer, useMemo, useCallback } from 'react';
import UserList from './UserList';
import CreateUser from './CreateUser';

function countActiveUsers(users) {
  console.log('활성 사용자 수를 세는중...');
  return users.filter(user => user.active).length;
}

const initialState = {
  inputs: {
    username: '',
    email: ''
  },
  users: [
    {
      id: 1,
      username: 'velopert',
      email: 'public.velopert@gmail.com',
      active: true
    },
    {
      id: 2,
      username: 'tester',
      email: 'tester@example.com',
      active: false
    },
    {
      id: 3,
      username: 'liz',
      email: 'liz@example.com',
      active: false
    }
  ]
};

function reducer(state, action) {
  switch (action.type) {
    case 'CHANGE_INPUT':
      return {
        ...state,
        inputs: {
          ...state.inputs,
          [action.name]: action.value
        }
      };
    case 'CREATE_USER':
      return {
        inputs: initialState.inputs,
        users: state.users.concat(action.user)
      };
    case 'TOGGLE_USER':
      return {
        ...state,
        users: state.users.map(user =>
          user.id === action.id ? { ...user, active: !user.active } : user
        )
      };
    case 'REMOVE_USER':
      return {
        ...state,
        users: state.users.filter(user => user.id !== action.id)
      };
    default:
      return state;
  }
}

function App() {
  const [state, dispatch] = useReducer(reducer, initialState);
  const nextId = useRef(4);

  const { users } = state;
  const { username, email } = state.inputs;

  const onChange = useCallback(e => {
    const { name, value } = e.target;
    dispatch({
      type: 'CHANGE_INPUT',
      name,
      value
    });
  }, []);

  const onCreate = useCallback(() => {
    dispatch({
      type: 'CREATE_USER',
      user: {
        id: nextId.current,
        username,
        email
      }
    });
    nextId.current += 1;
  }, [username, email]);

  const onToggle = useCallback(id => {
    dispatch({
      type: 'TOGGLE_USER',
      id
    });
  }, []);

  const onRemove = useCallback(id => {
    dispatch({
      type: 'REMOVE_USER',
      id
    });
  }, []);

  const count = useMemo(() => countActiveUsers(users), [users]);
  return (
    <>
      <CreateUser
        username={username}
        email={email}
        onChange={onChange}
        onCreate={onCreate}
      />
      <UserList users={users} onToggle={onToggle} onRemove={onRemove} />
      <div>활성사용자 수 : {count}</div>
    </>
  );
}

export default App;
```



#### useReducer 함수 사용법

##### step1)  컴포넌트 외부에 상태 업데이트 로직을 담은 reducer 함수(현재상태와 액션객체를 파라미터로 받아와서 새로운 상태를 반환) 작성

기본형태

function reducer(state, action){...}

'- state' : 현재상태

'- action: 업데이트와 관련된 정보를 가진 객체

'-return값': 컴포넌트가 지닐 새로운 상태(업데이트 될 값)



##### step2) useReducer 함수 사용

const[state, dispatch] = useReducer(reducer, initialState);

'- state' : 현재상태

'- dispatch : action을 발생시키는 함수=>reducer에 액션을 보낸다 (함수사용법 dispatch({type: 'INCREMENT'}))

​                     값을 업데이트 할때는 disacth에 action을 설정해서 업데이트 한다.

'-reducer :상태업데이트 로직을 담은 함수

'-initialState :초기상태



const[number,dispatch] = useReducer(reducer,0);

: 현재상태값에 number라는 이름을 주고, 액션을 발생시키는 함수 dispatch를 가져온다.

useReducer 첫번째 파라미터로 reducer함수를 넣어주고, 초기값은 0으로 설정한다



const onIncrease = () => {dispatch({type: 'INCREMENT'});};

: 액션이 필요한 함수에 dispatch를 호출하고 인자로 type이 담긴 객체 형태를 넣어준다.

type을 INCREMENT로 전달해주면 위 reducer함수에서 현재상태에서 +1 한 상태값을 반환해 준다



{count}

:상태가 업데이트가 되는 number변수를 가져온다.





## useReducer 작성법

### 0) useReducer의 필요한 4가지

- useReducer 함수
- 상태 stae
- 해당 이벤트에 맞는 dispatch 설정 / 이벤트와 dispatch 연결
- 컴포넌트 외부에서 state를 업데이트할 reducer 로직 작성

### 1) useReducer()

- 형태 : const [ **상태** , **액션을 발생시킬 함수** ] = **useReducer**( **reducer 함수** , **초기 상태** )
- dispatch / reducer / 초기상태 모두 마음대로 정해도 된다.

### 2) 상태

- state랑 같음

### 3-1) 이벤트에 적용 되는 distpatch 설정

- 형태 : **dispatch ( { type : '구분되는 값' } );**
- '**dispatch**'는 useReducer에서 선언 할 때의 '**액션을 발생시킬 함수**'와 같아야한다.
- dispatch 함수 내부의 값은 객체 형태이다.
- 객체 내부에서는 상태 업데이트를 구분하는 type을사용해야한다.
  

### 3-2) 이벤트 함수와 dispatch 연결

- 형태 : **함수 = () => { dispatch( {type : '구분 내용' );**
  

### 4) state 업데이트할 reducer 로직 작성

- 형태 : **function reducer( state, action ){
  swich(action.type){
  case '구분값'
  return state 변경
  }
  }**
- reducer라는 함수 이름은 useReducer선언할 때 **reducer 함수**와 같아야한다./
- state는 useReduer에서 선언 했던 상태를 의미한다. 즉, 선언한 상태 값을 가지고 업데이트가 이루어진다.
- action은 dispatcher에서 type의 값을 의미한다.
  

### 5) 정리



```react
import React, {useReducer } from 'react';

//컴포넌트 외부에서 상태를 변경하는 reduce함수 작성

function reducer(state,action){

.....

}



function counter{

**//useReduce 함수선언**

const [state, dispatch] = **useReducer**(reducer, initialState);

}

**//이벤트와 dispatch 적용**

 const **onCreate** = useCallback(() => {

  **dispatch**({

   type: **'CREATE_USER'**,

   user: {

  id: nextId.current,    username,    email

   }

  });

  nextId.current += 1;

 }, [username, email]);



 const count = useMemo(() => countActiveUsers(users), [users]);

 return (

  <>

   <CreateUser

    username={username}

    email={email}

    onChange={onChange}

    onCreate={**onCreate**}

   />

   <UserList users={users} onToggle={onToggle} onRemove={onRemove} />

      <div>활성사용자 수 : {count}</div>

  </>

 );




```



## 참고

## 기본 Hook

### `useState`

```
const [state, setState] = useState(initialState);
```

상태 유지 값과 그 값을 갱신하는 함수를 반환합니다.

최초로 렌더링을 하는 동안, 반환된 state(`state`)는 첫 번째 전달된 인자(`initialState`)의 값과 같습니다.

`setState` 함수는 state를 갱신할 때 사용합니다. 새 state 값을 받아 컴포넌트 리렌더링을 큐에 등록합니다.

```
setState(newState);
```

다음 리렌더링 시에 `useState`를 통해 반환받은 첫 번째 값은 항상 갱신된 최신 state가 됩니다.

> 주의
>
> React는 `setState` 함수 동일성이 안정적이고 리렌더링 시에도 변경되지 않을 것이라는 것을 보장합니다. 이것이 `useEffect`나 `useCallback` 의존성 목록에 이 함수를 포함하지 않아도 무방한 이유입니다.

#### 함수적 갱신

이전 state를 사용해서 새로운 state를 계산하는 경우 함수를 `setState` 로 전달할 수 있습니다. 그 함수는 이전 값을 받아 갱신된 값을 반환할 것입니다. 여기에 `setState`의 양쪽 형태를 사용한 카운터 컴포넌트의 예가 있습니다.

```
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
    </>
  );
}
```

”+“와 ”-” 버튼은 함수 형식을 사용하고 있습니다. 이것은 갱신된 값이 갱신되기 이전의 값을 바탕으로 계산되기 때문입니다. 반면, “Reset” 버튼은 카운트를 항상 0으로 설정하기 때문에 일반적인 형식을 사용합니다.

업데이트 함수가 현재 상태와 정확히 동일한 값을 반환한다면 바로 뒤에 일어날 리렌더링은 완전히 건너뛰게 됩니다.

> 주의
>
> 클래스 컴포넌트의 `setState` 메서드와는 다르게, `useState`는 갱신 객체(update objects)를 자동으로 합치지는 않습니다. 함수 업데이터 폼을 객체 전개 연산자와 결합함으로써 이 동작을 복제할 수 있습니다.
>
> ```
> const [state, setState] = useState({});
> setState(prevState => {
>   // Object.assign would also work
>   return {...prevState, ...updatedValues};
> });
> ```
>
> 다른 방법으로는 `useReducer`가 있는데 이는 여러개의 하윗값들을 포함한 state 객체를 관리하는 데에 더 적합합니다.

#### 지연 초기 state

`initialState` 인자는 초기 렌더링 시에 사용하는 state입니다. 그 이후의 렌더링 시에는 이 값은 무시됩니다. 만약 초기 state가 고비용 계산의 결과라면, 초기 렌더링 시에만 실행될 함수를 대신 제공할 수 있습니다.

```
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

#### state 갱신의 취소

State Hook을 현재의 state와 동일한 값으로 갱신하는 경우 React는 자식을 렌더링 한다거나 무엇을 실행하는 것을 회피하고 그 처리를 종료합니다. (React는 [`Object.is` 비교 알고리즘](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description)을 사용합니다.)

실행을 회피하기 전에 React에서 특정 컴포넌트를 다시 렌더링하는 것이 여전히 필요할 수도 있다는 것에 주의하세요. React가 불필요하게 트리에 그 이상으로 「더 깊게」는 관여하지 않을 것이므로 크게 신경 쓰지 않으셔도 됩니다만, 만약 렌더링 시에 고비용의 계산을 하고 있다면 `useMemo`를 사용하여 그것들을 최적화할 수 있습니다.

### ` `

### `useReducer`

```
const [state, dispatch] = useReducer(reducer, initialArg, init);
```

[`useState`](https://ko.reactjs.org/docs/hooks-reference.html#usestate)의 대체 함수입니다. `(state, action) => newState`의 형태로 reducer를 받고 `dispatch` 메서드와 짝의 형태로 현재 state를 반환합니다. (만약 Redux 에 익숙하다면 이것이 어떻게 동작하는지 여러분은 이미 알고 있을 것입니다.)

다수의 하윗값을 포함하는 복잡한 정적 로직을 만드는 경우나 다음 state가 이전 state에 의존적인 경우에 보통 `useState`보다 `useReducer`를 선호합니다. 또한 `useReducer`는 자세한 업데이트를 트리거 하는 컴포넌트의 성능을 최적화할 수 있게 하는데, 이것은 [콜백 대신 `dispatch`를 전달](https://ko.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down) 할 수 있기 때문입니다.

아래는 [`useState`](https://ko.reactjs.org/docs/hooks-reference.html#usestate) 내용에 있던 카운터 예제인데 reducer를 사용해서 다시 작성한 것입니다.

```
const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```

> 주의
>
> React는 `dispatch` 함수의 동일성이 안정적이고 리렌더링 시에도 변경되지 않으리라는 것을 보장합니다. 이것이 `useEffect`나 `useCallback` 의존성 목록에 이 함수를 포함하지 않아도 괜찮은 이유입니다.

#### 초기 state의 구체화

`useReducer` state의 초기화에는 두 가지 방법이 있습니다. 유스케이스에 따라서 한 가지를 선택하세요. 가장 간단한 방법은 초기 state를 두 번째 인자로 전달하는 것입니다.

```
  const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}  );
```

> 주의
>
> React에서는 Reducer의 인자로써 `state = initialState`와 같은 초기값을 나타내는, Redux에서는 보편화된 관습을 사용하지 않습니다. 때때로 초기값은 props에 의존할 필요가 있어 Hook 호출에서 지정되기도 합니다. 만약 초기값을 나타내는 것이 정말 필요하다면 `useReducer(reducer, undefined, reducer)`를 호출하는 방법으로 Redux를 모방할 수는 있겠지만, 이 방법을 권장하지는 않습니다.

#### 초기화 지연

초기 state를 조금 지연해서 생성할 수도 있습니다. 이를 위해서는 `init` 함수를 세 번째 인자로 전달합니다. 초기 state는 `init(initialArg)`에 설정될 것입니다.

이것은 reducer 외부에서 초기 state를 계산하는 로직을 추출할 수 있도록 합니다. 또한, 어떤 행동에 대한 대응으로 나중에 state를 재설정하는 데에도 유용합니다.

```
function init(initialCount) {  return {count: initialCount};}
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':      return init(action.payload);    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>        Reset
      </button>
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```

#### dispatch의 회피

Reducer Hook에서 현재 state와 같은 값을 반환하는 경우 React는 자식을 리렌더링하거나 effect를 발생하지 않고 이것들을 회피할 것입니다. (React는 [`Object.is` 비교 알고리즘](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description)을 사용합니다.)

실행을 회피하기 전에 React에서 특정 컴포넌트를 다시 렌더링하는 것이 여전히 필요할 수도 있다는 것에 주의하세요. React가 불필요하게 트리에 그 이상으로 「더 깊게」 까지는 가지 않을 것이므로 크게 신경 쓰지 않으셔도 됩니다. 만약 렌더링 시에 고비용의 계산을 하고 있다면 `useMemo`를 사용하여 그것들을 최적화할 수 있습니다.

### ` `