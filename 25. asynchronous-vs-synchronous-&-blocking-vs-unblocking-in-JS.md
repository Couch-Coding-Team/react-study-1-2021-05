# 비동기 vs 동기 프로그래밍 (blocking, unblocking code)

## 비동기(Asynchronous)?

> 순차적으로 진행되는 일반 코드에서는 한번에 한가지 사건만 발생하여, 이전에 호출된 함수가 끝나고 값을 산출할 때까지 기다려야 하는데, 이는 유저에게 프로그램 전체가 멈춘 것 처럼 보인다. 이는 컴퓨터 성능을 효율적으로 쓰지 못하는 처사이고, 그 동안 다른 작업을 수행할 수 있는 환경이 비동기 환경.

## blocking

> 예를 들어 웹 앱이 브라우저에서 특정 코드를 실행하느라 브라우저에게 제어권을 돌려주지 않으면, 마치 정지된 것 처럼 보일 수 있는 이런 일.

```javascript
const btn = document.querySelector("button");
btn.addEventListener("click", () => {
    let myDate;
    for (let i = 0; i < 10000000; i++) {
        let date = new Date();
        myDate = date;
    }

    console.log(myDate);

    let pElem = document.createElement("p");
    pElem.textContent = "This is a newly-added paragraph.";
    document.body.appendChild(pElem);
});
```

for 문 끝날 때까지 log 안뜸

## 왜 blocking 이 일어나는가?

> JS 는 Single-thread programming 이라서 이렇다!

## Threads

> Thread 는 작업을 완료하는데 사용할수 있는 단일 프로세스. 각 쓰레드는 한 번에 단 하나의 작업만 수행할 수 있다.

### Single-Threaded

```bash
// 순차적으로 실행되며, 이전 작업이 완료되어야 다음 작업이 진행됨.
Thread: Task A -> Task B -> Task C -> Task D
```

### Multi-Threaded

```bash
Thread1: Task A -> Task B
Thread2: Task C -> Task D
```

### JS 는 전통적으로 Single-threaded

cpu 의 멀티 쓰레드 지원에 상관없이 **main thread** 라는 단일 쓰레드만 사용.

```bash
Main Thread: Render circles to canvas -> Display alert()
```

### Web Workers

> 여러 개의 JS Chunk 를 동시에 실행할 수 있도록 worker 라는 별도의 thread 로 보낼 수 있다. 시간이 오래 걸리는 처리는 worker 로 처리하여 blocking 발생을 막을 수 있다.

```bash
Main Thread: Task A -> Task C
Worker Thread: Expensive Task B
```

```javascript
const btn = document.querySelector("button");
const worker = new Worker("worker.js");

btn.addEventListener("click", () => {
    worker.postMessage("Go!");

    let myDate;
    for (let i = 0; i < 10000000; i++) {
        let date = new Date();
        myDate = date;
    }

    let pElem = document.createElement("p");
    pElem.textContent = "This is a newly-added paragraph.";
    document.body.appendChild(pElem);
});

worker.onmessage = function (e) {
    console.log(e.data);
};

// 다른 예제
var w;

var i = 0;

function timedCount() {
  i = i + 1;
  postMessage(i);
  setTimeout("timedCount()",50000);
}

timedCount();

function startWorker() {
  if(typeof(Worker) !== "undefined") {
    if(typeof(w) == "undefined") {
      w = new Worker("demo_workers.js");
    }
    w.onmessage = function(event) {
      document.getElementById("result").innerHTML = event.data;
    };
  } else {
    document.getElementById("result").innerHTML = "Sorry, your browser does not support Web Workers...";
  }
}

function stopWorker() { 
  w.terminate();
  w = undefined;
}
```

이전과는 다르게 무거운 연산이 끝나기를 기다리지는 않는다.

## 비동기 코드
Web Worker 의 한계는, Web Worker 는 외부 파일이기 때문에 window object 나 DOM 에 접근 할 수 없다.
그리고 unblocking 이지만, 동기적으로 실행되어, web worker 로 받을 값을 원하는 시점에 사용할 수 없다.
이 때 브라우저를 통해 비동기적으로 작업을 하면 해결할 수 있다.

[mdn-what-is-asynchronous]: https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Concepts
